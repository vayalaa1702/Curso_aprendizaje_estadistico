# -*- coding: utf-8 -*-
"""Copy of Actividad_04_Binarios_Errores.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U2AT4beaxhjZNZ6ypfqhXg9W1YQe_ap4

<a href="https://colab.research.google.com/github/hernansalinas/autogrades/blob/main/Actividades_clase/Actividad_04_Binarios_Errores.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>



# Actividad 4
### Métodos computacionales para físicos  y astrónomos
### Universidad de Antioquia
### Prof: Hernan D. Salinas Jiménez
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/hernansalinas/autogrades.git
#path="libs"
path="autogrades/Actividades_clase/libs"
# %run -i {path}/libUnitTest.py

"""### Activity 1.0:

Implement a function that get the binary representation of an integer with name mybin, the algorithm should return
a string with 8 characters, the maximun number that represent the funcition is integer of 8 bit. The name of function is
mybin

Ejexample :

b=mybin(x)

b='00101000'
"""

##!/usr/bin/env python3
def mybin(x):
    print('__name__ = {}'.format(__name__))
   # Write your code here and change the next line as required
    return "111"

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test01.py

"""### Activity 2.0:

With the binary representation please try to implement the formula to recover the number.

Hint: Use as input the binary representation as a string and invert its order

```
number32(BIN):

```

Where BIN is a string with the binary number

Example:


Test your solution for the next number:

number32("00111110001000000000001000010000")
"""

def number32(BIN):
    return None

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test02.py

#representacion de un numero de 32 bit
b0 = "00111110001000000000000000000000"
b=b0[::-1] # invierte a b0

#identificamos la posicion
pos_signo = b[31]
pos_exponente=b[23:31]
pos_fraccion=b[0:23]
pos_exponenteinv=b[31:23]
print(b,"numero invertido en este caso lo llamamos b")
print(b[23:31],"exponente")
print(b[31:23],"exponente invertido")
print(b[31],"signo del numero")
print(b[0:23],"fraccion del numero","mantiza tal vez")

#vamos a hacer un codigo para e que indica la posicion del exponente
def e_(pos_exponente):
  e = 0 #inicializa una variable para almacenarlo en una sumatoria
  for i in range(0, 8):
    e = e + int(pos_exponente[i]) * 2**i # el int se usa para interpretar la cadena como un numero entero
  return e

def fraccion(pos_fraccion):
  s=0
  for i in range(0,22):
    s = s + int(pos_fraccion[i])/2**(23-i)
  return s


e=e_(b[23:31])
f=fraccion(b[0:23])
(-1)**int(b[31])/(2**(127-e)) *(1 + f )

"""### Activity 3.0:
1. Write a python script that calculates the double precision number represented by a 64-bits binary.

the name of function should be:
```
number64(BIN):

```

2. What is the number represented by:

BIN="0 10000000011 1011100100001111111111111111111111111111111111111111"
"""

def binario_doble_precision(BIN):
  if len(BIN)!=64:
    raise ValueError("Se necesita una cadena de 64 bits de longitud")
    bit_signo=int(BIN[0])
    bit_exponente=int(BIN[1:12])
    bit_fraccion=int(BIN[12:])

  numero_con_precision=binario_doble_precision(BIN)
  print("numero en doble precision ",numero_con_precision)

# Commented out IPython magic to ensure Python compatibility.
# %run -i {path}/Act_02/test03.py

BIN="0100000000111011100100001111111111111111111111111111111111111111"
b=BIN[::-1]
print(b)

#identifico las posiciones
pos_signo1=b[63]
pos_exponente1=b[52:63]
pos_fraccion1=b[0:53]
print(b[63],"signo del numero")
print(b[52:63],"exponente")
print(b[0:53],"fraccion")

def m_(pos_exponente1):
    m=0
    for i in range(0,11):
        m = m + int(pos_exponente1[i]) * 2**i
    return m

def fraccion1(pos_fraccion1):
    p=0
    for i in range(0,52):
        p= p+int(pos_fraccion1[i]) * 2**(52-i)
    return p

m=m_(b[52:63])
f=fraccion1(b[0:53])
(-1)**int(b[61])/(2**(1024-e))*(1+f)

